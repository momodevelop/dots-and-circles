// Generated by Codegen
#ifndef LIST_DEBUG_CONSOLE_COMMAND
#define LIST_DEBUG_CONSOLE_COMMAND
// list_debug_console_command = list name
// array_debug_console_command = array name
// debug_console_command = type name
// ListDebugConsoleCommand_ = function prefix



// NOTE(Momo): Requires you to #include the definition of array_debug_console_command before this
struct list_debug_console_command : array_debug_console_command {
    u32 Capacity; // Total number of borrowable objects.
};

// Constructors
static inline list_debug_console_command
ListDebugConsoleCommand_CreateFromMemory(ListDebugConsoleCommand_* Arr, u32 Capacity) {
    list_debug_console_command Ret = {};
    Ret.E = Arr;
    Ret.Capacity= Capacity;
    return Ret;
}

static inline list_debug_console_command
ListDebugConsoleCommand_CreateFromArena(arena* Arena, u32 Capacity) {
    list_debug_console_command Ret = {};
    Ret.E = Arena_PushArray(ListDebugConsoleCommand_, Arena, Capacity);
    Ret.Capacity = Capacity;
    return Ret;
}


static inline void 
ListDebugConsoleCommand_Clear(list_debug_console_command* List) {
    List->Count = 0;
}

static inline void
ListDebugConsoleCommand_Copy(list_debug_console_command* Dest, array_debug_console_command* Src) {
    Assert(Src->Count <= Dest->Capacity);
    for (u32 I = 0; I < Src->Count; ++I ) {
        Dest->E[I] = Src->E[I];
    }
    Dest->Count = Src->Count;
}


static inline u32
ListDebugConsoleCommand_Remaining(list_debug_console_command* List) {
    return List->Capacity - List->Count;
}

static inline b32
ListDebugConsoleCommand_Push(list_debug_console_command* List, ListDebugConsoleCommand_ Obj) {
    if(List->Count >= List->Capacity) {
		return false;
	}
    List->E[List->Count++] = Obj;
	return true;
}

static inline b32
ListDebugConsoleCommand_PushArray(list_debug_console_command* Dest, array_debug_console_command Src) {
    if(Dest->Count + Src.Count > Dest->Capacity) {
		return false;
	}
    for ( u32 i = 0; i < Src.Count; ++i ) {
        Dest->E[Dest->Count++] = Src.E[i];
    }
	return true;
}


static inline void
ListDebugConsoleCommand_Pop(list_debug_console_command* List) {
    Assert(List->Count > 0);
    --List->Count;
}

static inline ListDebugConsoleCommand_*
ListDebugConsoleCommand_Front(list_debug_console_command* List) {
    Assert(List->Count > 0);
    return List->E;
}

static inline ListDebugConsoleCommand_*
ListDebugConsoleCommand_Back(list_debug_console_command* List) {
    Assert(List->Count > 0);
    return List->E + List->Count - 1;
}


static inline void
ListDebugConsoleCommand_Remove(list_debug_console_command* List, u32 Index) {
    Assert(Index < List->Count);
    for (; Index < List->Count - 1; ++Index) {
        List->E[Index] = List->E[Index + 1];
    }
    --List->Count;
}

// Use this to remove objects if order does not matter!
static inline void
ListDebugConsoleCommand_SwapRemove(list_debug_console_command* List, u32 Index) {
    //(*Obj) = List->E[List->Count - 1];
    List->E[Index] = List->E[List->Count - 1];
    --List->Count;
}



/*
static inline usize
ListDebugConsoleCommand_RemoveIf(list_debug_console_command* List, unary_comparer UnaryComparer) {
    usize Index = Find(List, UnaryComparer);
    Remove(List, Index);
    return Index;
}

*/
#endif